{
  "hash": "6349d929a0e6401b3472e973e89a49d4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: DES Model\nformat: live-html\nresources:\n    - data\n    - arrivals.csv\nengine: knitr\nwebr:\n  packages:\n    - simmer\n    - simmer.bricks\n    - ggplot2\n    - tibble\n---\n::: {.cell}\n\n:::\n\n\n\n::: {.callout-tip collapse=\"true\" title=\"Model Code\" icon=\"false\"}\n\n::: {.cell}\n```{webr}\n#| echo: true\n#| warning: false\n#| message: false\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)\n\n## 2. Default values and constants\n\n### 2.1 Distribution parameters\n\n#' Mean and Variance of the underlying Normal Distribution\n#' \n#' @description\n#' `normal_moments_from_lognormal` calculates the mu and sigma\n#' of the normal distribution underlying a lognormal\n#' mean and standard \n#'\n#' @details\n#' `rlnorm` from `stats` is designed to sample from the lognormal distribution. \n#' The parameters is expects are moments of the underlying normal distribution\n#' Using sample mean and standard deviation this function calculates \n#' the mu and sigma of the normal distribution. source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal-data-with-specified-mean-and-variance.html\n#' \n#' @param mean A number. Sample mean.\n#' @param stdev A number. Sample standard deviation\n#' @returns A list \nnormal_moments_from_lognormal <- function(mean, std){\n  phi <- sqrt(std^2 + mean^2)\n  mu <- log(mean**2/phi)\n  sigma <- sqrt(log(phi^2/mean^2))\n  return(list(\"mu\" = mu, \"sigma\" = sigma))\n}\n\n\n# sign-in/triage parameters\nDEFAULT_TRIAGE_MEAN <- 3.0\n\n# registration parameters (lognormal distribution)\nDEFAULT_REG_PARAMS <- normal_moments_from_lognormal(5.0, sqrt(2.0))\n\n# examination parameters\nDEFAULT_EXAM_PARAMS = list(mean=16.0, var=3.0)\n\n# trauma/stabilisation\nDEFAULT_TRAUMA_MEAN <- 90.0\n\n# Trauma treatment (lognormal distribution)\nDEFAULT_TRAUMA_TREATMENT_PARAMS <- normal_moments_from_lognormal(30.0, sqrt(4.0))\n\n# Non trauma treatment (lognormal distribution)\nDEFAULT_NON_TRAUMA_TREATMENT_PARAMS <- normal_moments_from_lognormal(13.3, sqrt(2.0))\n\n# prob patient requires treatment given trauma\nDEFAULT_NON_TRAUMA_TREAT_P <- 0.60\n\n# proportion of patients triaged as trauma\nDEFAULT_PROB_TRAUMA <- 0.12\n\n### 2.3 Resource Counts\nDEFAULT_N_TRIAGE <- 1\nDEFAULT_N_REG <- 1\nDEFAULT_N_EXAM <- 3\n\n# stabilisation rooms\nDEFAULT_N_TRAUMA <- 1\n\n# Non-trauma cubicles\nDEFAULT_NON_TRAUMA_CUBICLES <- 1\n\n# trauma pathway cubicles\nDEFAULT_TRAUMA_CUBICLES <- 1\n\n### 2.4 Simulation model run settings\n\n# Random seed - this will be investigated for CRN\nSEED <- 42\n\n# default results collection period\nDEFAULT_RESULTS_COLLECTION_PERIOD <- 60 * 19\n\n# number of replications.\nDEFAULT_N_REPS <- 5\n\n# Show the a trace of simulated events\n# 1 = show, 0 = do not show.\nLOG_LEVEL <- 1\n\n# Hourly arrivals data read from csv file\nDEFAULT_ARRIVALS_DATA <- \"data/arrivals.csv\"\n\narrivals <- DEFAULT_ARRIVALS_DATA\n\n## 3. Functions\n\nload_arrival_data <- function(arrivals){\n  list.files(\"data\")\n  df <- read.csv(arrivals)\n  # arrivals per minute...\n  df$arrival_rate2 <- df$arrival_rate/60.0\n  \n  # create 60 minute increments for period\n  df$period = seq(0, (nrow(df)-1)*60, by=60)\n  return(df)\n}\n\n#' Sample a patient type\n#' \n#' @description\n#' `sample_arrival_type` samples if a patient type is trauma or non-trauma\n#' with a given probability.\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is Trauma or Non-Trauma.  The return values are \n#' 1 = Trauma, 2 = Non-trauma.\n#' @param p A number: the probability a patient has trauma on arrival\nsample_arrival_type <- function(p, n=1){\n  ifelse(rbern(n, prob = DEFAULT_PROB_TRAUMA) == 1, 1, 2)\n}\n\n#' Sample a if a non-trauma patient requires treatment\n#' \n#' @description\n#' `sample_nt_trauma_treatment` samples if a non-trauma patient\n#' requires cubicle treatment\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is requires treatment or not.  The return values are \n#' 1 = Treatment, 0 = No treatment\n#' @param p A number: The probability the patient requires treatment\nsample_nt_trauma_treatment <- function(p){\n  ifelse(rbern(1, prob = p) == 1, 1, 0)\n}\n\nnspp_thinning <- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval <- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max <- max(data$arrival_rate2)\n  \n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t <- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t <- data$arrival_rate2[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u <- Inf\n    rejects <- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time <- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio <- lambda_t / lambda_max\n    while(u >= ratio){\n      rejects <- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time <- inter_arrival_time + rexp(1, lambda_max)\n      u <- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n    \n    return(inter_arrival_time)\n  }\n}\n\n## 4. Model parameterisation\n\ncreate_experiment <- function(n_triage_bays=DEFAULT_N_TRIAGE,\n                              n_reg_clerks=DEFAULT_N_REG,\n                              n_exam_rooms=DEFAULT_N_EXAM,\n                              n_trauma_rooms=DEFAULT_N_TRAUMA,\n                              n_non_trauma_cubicles=DEFAULT_NON_TRAUMA_CUBICLES,\n                              n_trauma_cubicles=DEFAULT_TRAUMA_CUBICLES,\n                              triage_mean=DEFAULT_TRIAGE_MEAN,\n                              stabilisation_mean=DEFAULT_TRAUMA_MEAN,\n                              trauma_treat_params=DEFAULT_TRAUMA_TREATMENT_PARAMS,\n                              reg_params=DEFAULT_REG_PARAMS,\n                              exam_params=DEFAULT_EXAM_PARAMS,\n                              prob_non_trauma_treat=DEFAULT_NON_TRAUMA_TREAT_P,\n                              nontrauma_treat_params=DEFAULT_NON_TRAUMA_TREATMENT_PARAMS,\n                              prob_trauma=DEFAULT_PROB_TRAUMA,\n                              arrival_data_path=NSPP_PATH,\n                              log_level=LOG_LEVEL) {\n  \n  # load arrival data\n  arrival_data <- load_arrival_data(arrivals)\n  \n  # create list of parameters\n  experiment <- list(n_triage_bays=n_triage_bays,\n                     n_reg_clerks=n_reg_clerks,\n                     n_exam_rooms=n_exam_rooms,\n                     n_trauma_rooms=n_trauma_rooms,\n                     n_non_trauma_cubicles=n_non_trauma_cubicles,\n                     n_trauma_cubicles=n_trauma_cubicles,\n                     triage_mean=triage_mean,\n                     stabilisation_mean=stabilisation_mean,\n                     trauma_treat_params=trauma_treat_params,\n                     reg_params=reg_params,\n                     exam_params=exam_params,\n                     prob_non_trauma_treat=prob_non_trauma_treat,\n                     nontrauma_treat_params=nontrauma_treat_params,\n                     prob_trauma=prob_trauma,\n                     arrival_data=arrival_data,\n                     log_level=log_level)\n  \n  return(experiment)\n}     \n\n## 5. Patient Trajectories\n\n### 5.1. Trauma Patients\ncreate_trauma_pathway <- function(exp){\n  \n  trauma_pathway <- trajectory(name=\"trauma_pathway\") %>%\n    set_attribute(\"patient_type\", 1) %>%\n    # log patient arrival\n    log_(function() {paste(\"**Trauma arrival\")}, level=1) %>% \n    \n    # triage \n    set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %>%\n    visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %>%\n    log_(function() {paste(\"(T) Triage wait time:\",\n                           now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %>%\n    \n    # request trauma room for stabilization\n    set_attribute(\"start_trauma_room_wait\", function() {now(exp$env)}) %>%\n    visit(\"trauma_room\", function() rexp(1, 1/exp$stabilisation_mean)) %>%\n    log_(function() {paste(\"(T) Trauma room wait time:\",\n                           now(exp$env) - get_attribute(exp$env, \"start_trauma_room_wait\"))},\n         level=1) %>%\n    \n    # request treatment cubicle\n    set_attribute(\"start_trauma_treat_wait\", function() {now(exp$env)}) %>%\n    visit(\"trauma_treat_cubicle\", function() rlnorm(1, exp$trauma_treat_params$mu,\n                                                    exp$trauma_treat_params$sigma)) %>%\n    log_(function() {paste(\"********************(T) Trauma treatment cubicle wait time:\",\n                           now(exp$env) - get_attribute(exp$env, \"start_trauma_treat_wait\"))},\n         level=1) %>% \n    \n    # store the total time in system \n    set_attribute(\"total_time\", \n                  function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n  \n  return(trauma_pathway)\n}\n\n### 5.2 Non-trauma patients\n\ncreate_nt_cubicle_treatment <- function(exp){\n  \n  nt_cubicle_treatment <- trajectory() %>% \n    log_(function() {paste(\"NT patient requirement treatment\")},\n         level=1) %>% \n    seize(resource=\"nontrauma_treat_cubicle\", amount=1) %>% \n    \n    timeout(task = function() rlnorm(1, exp$nontrauma_treat_params$mu,                                                     exp$nontrauma_treat_params$sigma)) %>%\n    release(resource = \"nontrauma_treat_cubicle\", amount = 1) %>% \n    log_(function() {paste(\"NT treatment complete\")},\n         level=1) %>% \n    return(nt_cubicle_treatment)\n}\n\ncreate_non_trauma_pathway <- function(exp){\n  # log messages\n  ARRIVAL_MSG = \"**Non-Trauma arrival**\"\n  TRIAGE_MSG = \"(NT) Triage wait time:\"\n  REG_MSG = \"Reg wait time:\"\n  EXAM_MSG = \"Exam wait time:\"\n  EXIT_MSG = \"NT Total time in system:\"\n  \n  # optional trajectory for proportion of patients that requirement treatment\n  nt_cubicle_treatment <- create_nt_cubicle_treatment(exp)\n  \n  non_trauma_pathway <- trajectory(name=\"non_trauma_pathway\") %>%\n    set_attribute(\"patient_type\", 2) %>%\n    # log non_trauma arrival\n    log_(function() {paste(ARRIVAL_MSG)}, level=1) %>% \n    \n    # store start of waiting time for log calculations\n    set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %>%\n    # queue and use triage bay\n    visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %>%\n    log_(function() {paste(TRIAGE_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %>%\n    \n    # queue and use registration clerk\n    set_attribute(\"start_reg_wait\", function() {now(exp$env)}) %>%\n    visit(\"registration_clerk\", function() rlnorm(1, exp$reg_params$mu, \n                                                  exp$reg_params$sigma)) %>%\n    log_(function() {paste(REG_MSG, now(exp$env) - get_attribute(exp$env, \"start_reg_wait\"))},\n         level=1) %>%\n    \n    # queue and use examination room\n    set_attribute(\"start_exam_wait\", function() {now(exp$env)}) %>%\n    visit(\"examination_room\",  function() rnorm(1, exp$exam_params$mean, \n                                                sqrt(exp$exam_params$var))) %>%\n    log_(function() {paste(EXAM_MSG, now(exp$env) - get_attribute(exp$env, \"start_exam_wait\"))},\n         level=1) %>%\n    \n    # a Proportion of patients require treatment in a cubicle\n    branch (\n      function() sample_nt_trauma_treatment(exp$prob_non_trauma_treat), continue=T,\n      nt_cubicle_treatment\n    ) %>% \n    log_(function() {paste(EXIT_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %>% \n    # store the total time in system \n    set_attribute(\"total_time\", \n                  function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n  \n  return(non_trauma_pathway)\n}\n\n## 6. Modelling patient arrivals\n\ncreate_arrival_generator <- function(exp){\n  \n  DEPART_MSG <- \"A patient has departed the UTC\"\n  \n  # create and parameterise the trauma pathway trajectory\n  trauma_pathway <- create_trauma_pathway(exp)\n  \n  # create and parameterise the non-trauma pathway trajectory\n  non_trauma_pathway <- create_non_trauma_pathway(exp)\n  \n  patient_arrival <- trajectory() %>%\n    branch(\n      function() sample_arrival_type(exp$prob_trauma), continue=T,\n      trauma_pathway,\n      non_trauma_pathway\n    ) %>%\n    log_(function() {paste(DEPART_MSG)},level=1) %>% \n    set_attribute(\"departed\", 1)\n  \n  return(patient_arrival)\n}\n\n## 7. Single run of the model\n\nsingle_run <- function(env, exp, \n                       rep_number=1, \n                       run_length=DEFAULT_RESULTS_COLLECTION_PERIOD, \n                       debug_arrivals=FALSE){\n  # add the simmer environment to the experiment list.\n  exp <- c(exp, env=env) \n  \n  # Create the arrivals generator\n  arrival_gen <- create_arrival_generator(exp)\n  \n  # create model and run.\n  env %>% \n    add_resource(\"triage_bay\", exp$n_triage_bays) %>%\n    add_resource(\"registration_clerk\", exp$n_reg_clerks) %>%\n    add_resource(\"examination_room\", exp$n_exam_rooms) %>%\n    add_resource(\"trauma_room\", exp$n_trauma_rooms) %>%\n    add_resource(\"trauma_treat_cubicle\", exp$n_trauma_cubicles) %>%\n    add_resource(\"nontrauma_treat_cubicle\", exp$n_non_trauma_cubicles) %>%\n    add_generator(\"Patient\", arrival_gen, \n                  function() nspp_thinning(now(env), exp$arrival_data, \n                                           debug=debug_arrivals),\n                  mon=2) %>% \n    run(until=run_length)\n  \n  # return environment and all of its results.\n  return(env)\n}\n\n\nmultiple_replications <- function(exp, n_reps=5, random_seed=0){\n  \n  set.seed(random_seed)\n  \n  # note unlike in simmer documentation we use a traditional for loop\n  # instead of lapply. This allows us to separate env creation\n  # from run and preserve the environment interaction between NSPP \n  # and current sim time.\n  # TO DO: look again -> can treat_sim be created inside single_run()\n  print(\"running replications...\")\n  reps = vector()\n  for(rep in 1:n_reps){\n    treat_sim <- simmer(\"TreatSimmer\", log_level=exp$log_level)\n    treat_sim <- single_run(treat_sim, exp)\n    # store the latest simulation environment and its results.\n    reps <- c(reps, treat_sim)\n  }\n  print(\"Complete.\")\n  return(reps)\n}\n\n```\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\" title=\"Output Analysis\" icon=\"false\"}\n\n::: {.cell}\n```{webr}\n#| echo: true\n#| warning: false\n#| message: false\n\n## 9. Results analysis\n\nget_resource_counts <- function(exp) {\n  resource = c(\"triage_bay\", \n               \"registration_clerk\", \n               \"examination_room\",\n               \"trauma_room\",\n               \"trauma_treat_cubicle\",\n               \"nontrauma_treat_cubicle\")\n  \n  resource_counts = c(exp$n_triage_bays,\n                      exp$n_reg_clerks,\n                      exp$n_exam_rooms,\n                      exp$n_trauma_rooms,\n                      exp$n_trauma_cubicles,\n                      exp$n_non_trauma_cubicles)\n  \n  df_resource <- data.frame(resource)\n  df_resource$count <- resource_counts\n  return(df_resource)\n}\n\n\n# assumes df is monitored arrivals\nwaiting_time <- function(df){\n  df$waiting_time <-df$end_time - df$start_time - df$activity_time  \n  return(df)\n}\n\nresource_waiting_times_by_replication <- function(reps) {\n  # - WAITING TIMES FOR RESOURCES - #\n  \n  cols <- c(\"resource\", \"replication\")\n  waiting_times_wide <- get_mon_arrivals(reps, per_resource=TRUE) %>%\n    # waiting time = end time - start time - activity time\n    waiting_time() %>% \n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %>%\n    # mean for each replication\n    summarise(rep_waiting_time=mean(waiting_time)) %>% \n    # recode kpi names\n    mutate(resource=recode(resource,\n                           'triage_bay'='01a_triage_wait',\n                           'registration_clerk'='02a_registration_wait',\n                           'examination_room'='03a_examination_wait',\n                           'nontrauma_treat_cubicle'='04a_treatment_wait(non_trauma)',\n                           'trauma_room'='06a_stabilisation_wait',\n                           'trauma_treat_cubicle'='07a_treatment_wait(trauma)')) %>%\n    # organise\n    arrange(resource) %>% \n    # long to wide format ...\n    spread(resource, rep_waiting_time)\n  \n  return(waiting_times_wide)\n}\n\n\n### 9.2. Resource utilisation KPIs\n\nget_resource_counts <- function(exp) {\n  resource = c(\"triage_bay\", \n               \"registration_clerk\", \n               \"examination_room\",\n               \"trauma_room\",\n               \"trauma_treat_cubicle\",\n               \"nontrauma_treat_cubicle\")\n  \n  resource_counts = c(exp$n_triage_bays,\n                      exp$n_reg_clerks,\n                      exp$n_exam_rooms,\n                      exp$n_trauma_rooms,\n                      exp$n_trauma_cubicles,\n                      exp$n_non_trauma_cubicles)\n  \n  df_resource <- data.frame(resource)\n  df_resource$count <- resource_counts\n  return(df_resource)\n}\n\n\n# simple calculation of total busy time / total scheduled resource time.\nresource_utilisation <- function(df, scheduled_time){\n  df$util = df$in_use / (scheduled_time * df$count)  \n  return(df)\n}\n\n# calculate resource utilisation and return table (rows = reps and cols = resources)\nresource_utilisation_by_replication <- function(reps, exp, results_collection_period){\n  \n  # get results dataframe broken down by resource and replication.\n  cols <- c(\"resource\", \"replication\")\n  \n  # utilisation calculation:\n  # simple calculation of total busy time / total scheduled resource time.\n  # where total scheduled time = n_resource * results collection period.\n  util_wide <- get_mon_arrivals(reps, per_resource=TRUE) %>%\n    # total activity time in each replication per resource (long format)\n    group_by(across(all_of(cols))) %>%\n    summarise(in_use=sum(activity_time)) %>% \n    # merge with the number of resources available\n    merge(get_resource_counts(exp), by=\"resource\", all=TRUE) %>% \n    # calculate the utilisation using scheduled resource availability\n    resource_utilisation(results_collection_period) %>% \n    # drop total activity time and count of resources\n    subset(select = c(replication, resource, util)) %>% \n    # recode names\n    mutate(resource=recode(resource,\n                           'triage_bay'='01b_triage_util',\n                           'registration_clerk'='02b_registration_util',\n                           'examination_room'='03b_examination_util',\n                           'nontrauma_treat_cubicle'='04b_treatment_util(non_trauma)',\n                           'trauma_room'='06b_stabilisation_util',\n                           'trauma_treat_cubicle'='07b_treatment_util(trauma)')) %>%\n    arrange(resource) %>% \n    # long to wide format...\n    spread(resource, util)\n  \n  return(util_wide)\n}\n\n\n### 9.3. Patient arrival numbers output\n\n# number of arrivals in each replication\narrivals_by_replication <- function(envs){\n  results <- vector()\n  for(env in envs){\n    results <- c(results, get_n_generated(env, \"Patient\"))\n  }\n  \n  results <- data.frame(replication = c(1:length(results)), \n                        arrivals = results)\n  colnames(results) <- c(\"replication\", \"00_arrivals\")\n  return(results)\n}\n\n\n### 9.4 System level KPIs\n# mean time in the system and throughput\nsystem_kpi_for_rep_i <- function(reps, rep_i){\n  \n  # get attributes\n  att <- get_mon_attributes(reps)\n  \n  # for speed - limit to replication number.\n  data_wide <- subset(att[att$replication == rep_i,], select = c(name, key, value)) %>% \n    spread(key, value)\n  \n  # Patient type 1: trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_1 = mean(data_wide[data_wide$patient_type == 1,]$total_time, na.rm = TRUE)\n  \n  # Patient type 2: non_trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_2 = mean(data_wide[data_wide$patient_type == 2,]$total_time, na.rm = TRUE)\n  \n  # Throughput - discharges during opening hours.\n  throughput <- sum(data_wide$departed, na.rm=TRUE)\n  \n  # store and return data.frame of results\n  rep_results <- data.frame(\"replication\" = rep_i,\n                            \"05_total_time(non-trauma)\" = mean_time_2,\n                            \"08_total_time(trauma)\" = mean_time_1, \n                            \"09_throughput\"= throughput)\n  \n  colnames(rep_results) = c(\"replication\",\n                            \"05_total_time(non-trauma)\",\n                            \"08_total_time(trauma)\", \n                            \"09_throughput\")\n  return(rep_results)\n}\n\nsystem_kpi_by_replication <- function(reps){\n  # calcs total time by patient type and total throughput\n  \n  # empty dataframe for attribute calculations.\n  att_results <- data.frame(matrix(ncol = 4, nrow = 0))\n  colnames(att_results) <- c(\"replication\", \n                             \"05_total_time(non-trauma)\", \n                             \"08_total_time(trauma)\", \n                             \"_09_throughput\")\n  \n  # add each rep separately as this works faster with pivot\n  for(rep_i in 1:length(reps)){\n    att_results <- rbind(att_results, system_kpi_for_rep_i(reps, rep_i))\n  }\n  \n  # return the KPIs by replications\n  return(att_results)\n}\n\n\n### 9.5. Function to create the replications table\n\n\nreplication_results_table <- function(reps, exp, results_collection_period){\n  # generate and merge all results tables on the replication column\n  results_table <- arrivals_by_replication(reps) %>% \n    merge(resource_waiting_times_by_replication(reps), by=\"replication\", all=TRUE) %>% \n    merge(resource_utilisation_by_replication(reps, exp,\n                                              results_collection_period),\n           by=\"replication\", all=TRUE) %>% \n    merge(system_kpi_by_replication(reps), by=\"replication\", all=TRUE) %>% \n    # sort by column names to get \"replication\" followed by ordered 00_, 01a, 01b and so on...\n    select(replication, sort(tidyselect::peek_vars()))\n  \n  results_table \n}\n\n\n### 9.6 Histogram of replications\n\nhistogram_of_replications <- function(rep_table, column_name, unit_label, n_bins=10){\n  \n  # Divide the x range for selected column into n_bins\n  binwidth <- diff(range(select(rep_table, all_of(column_name))))/n_bins\n  \n  g <- ggplot(rep_table, aes(.data[[column_name]])) +\n    geom_histogram(binwidth = binwidth, fill=\"steelblue\", colour = \"black\") + \n    xlab(paste(column_name, \" (\", unit_label, \")\")) + \n    ylab(\"Replications\")\n  \n  return(g)\n}\n\n\n### 9.7 Results summary table\n\n# modified summary table function\n# modified to remove passing the Experiment - not needed.\ncreate_summary_table <- function(rep_table, dp=2){\n  # mean of all columns, but ignore rep number\n  mean_values <- data.frame(colMeans(rep_table[c(2:length(rep_table))]))\n  colnames(mean_values) <- c(\"mean\")\n  return(round(mean_values, dp))\n  \n}\n\n```\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\" title=\"Run Script\" icon=\"false\"}\n\n::: {.cell}\n```{webr}\nn_triage <- DEFAULT_N_TRIAGE\nn_reg <- DEFAULT_N_REG\nn_exam <- DEFAULT_N_EXAM\nn_nt_cubicles <- DEFAULT_NON_TRAUMA_CUBICLES\nn_trauma <- DEFAULT_N_TRAUMA\nn_trauma_cubicles <- DEFAULT_TRAUMA_CUBICLES\nprob_trauma <- DEFAULT_PROB_TRAUMA\nmean_trauma_treat_time <- DEFAULT_TRAUMA_TREATMENT_PARAMS$mu\nvar_trauma_treat_time <- DEFAULT_TRAUMA_TREATMENT_PARAMS$sigma\nmean_exam_time <- DEFAULT_EXAM_PARAMS$mean\nvar_exam_time <- DEFAULT_EXAM_PARAMS$var\n\n# Function to run the simulation\nrun_simulation <- function(n_triage, n_reg, n_exam, n_nt_cubicles, n_trauma, n_trauma_cubicles) {\n  # Create the experiment using input parameters\n  exp <- create_experiment(\n    n_triage_bays = n_triage,\n    n_reg_clerks = n_reg,\n    n_exam_rooms = n_exam,\n    n_non_trauma_cubicles = n_nt_cubicles,\n    n_trauma_rooms = n_trauma,\n    n_trauma_cubicles = n_trauma_cubicles,\n    log_level = 0\n  )\n  \n  # Run multiple replications of the model\n  df_model_reps <- multiple_replications(exp = exp, n_reps = 5, random_seed = 42)\n  \n  # Return a replications table\n  results <- replication_results_table(df_model_reps, exp, DEFAULT_RESULTS_COLLECTION_PERIOD)\n  return(results)\n}\n\n# Run the simulation with default parameters\nsimulation_results <- run_simulation(n_triage, n_reg, n_exam, n_nt_cubicles, n_trauma, n_trauma_cubicles)\n\n# Create summary table of the simulation results\nsummary_table <- create_summary_table(simulation_results)\nprint(summary_table)\n\n# Plot histogram of replications\ng <- histogram_of_replications(simulation_results, \"09_throughput\", \"patients/day\", n_bins = 10)\nprint(g)\n\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}